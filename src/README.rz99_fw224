Rene Zhang - rz99
Fukang Wen - fw224

Implementation details of Project 3 for CS4411 - Fall 2014
================================================================================
Important Design Decisions
  - We assume it is the job of minisocket_send to fragment the input message
    into fragments of data to send
  - We encode the MSG_FIN packet's seq number to be 0 (unused) to differentiate
    it from the other packets. This is to handle the case where the window size
    becomes 2 when MSG_FIN packets are sent (potentially alongside other packets).

================================================================================
Minisocket
  - Minisocket_send is implemented using a finite state machine with 3 states.
    One state is the acknowledge state where we receive an ack packet from the
    remote connection and move on to the next chunk of data. One state is the
    send state where we try to send data until the maxed number of retries.
    One state is the closed state where it indicates that the minisocket is
    closed and we should terminate.
  - Minisocket_send blocks each time after it sends something and waits for
    either the network_handler to wake it up after receiving an ack, or the
    alarm to wake it up after some timeout time.
  - We decide that it's the minisocket_send's job to fragment and send the data
    in the largest chunks possible.
  - Minisocket_receive is implemented using a finite state machine with 2 states.
    One state is the receiving state where we take data from the stream. One state
    is the closed state where it indicates that the minisocket is closed.
  - Minisocket_receive blocks if the stream is empty and until the stream has some
    data in it.
  - Minisocket_close is implemented using a finite state machine with 4 states.
  - Minisocket_close attempts to send MSG_FIN packets to the remote connection
    until it reaches the max number of retries. Then, it sends signals to waiting
    minisocket_send and minisocket_receive applications to tell them to terminate
    in the closed state. Then, it blocks until all of these send and receive
    applications have exited and then frees the minisocket.
================================================================================
Stream
  - Implements a stream using a queue, where each node holds an interrupt_arg_t
  - Stream contains the index that denotes where the next data of the current
    node starts
  - We implement stream_add as efficiently as possible because this is called
    by the network handler. stream_add simply append the interrupt_arg_t onto
    the queue
  - We implement stream_take to take as much data as available at this time to
    meet the needs of the request, which takes longer as it loops over the whole
    stream in the worst case. However, this is fine as stream_take is called
    by the user application.

================================================================================
Test cases

conn-network4
  - tests for minisocket_close behavior by closing the port first and then
    sending the data.
================================================================================

