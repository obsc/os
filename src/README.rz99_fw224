Rene Zhang - rz99
Fukang Wen - fw224

Implementation details of Project 2 for CS4411 - Fall 2014
================================================================================
Alarm

alarm.h
  - added initialize_alarms() which initializes the alarm priority queue
    structure
  - added check_alarms() which is called every interrupt and runs any possible
    alarms
alarm.c
  - time is held in milliseconds
  - alarm structure keeps track of function, argument, and time it should be run
  - deregister searches through the priority queue, deletes and frees the node
    if it exists, otherwise we assume that the alarm has already been freed
  - register and deregister both run in worst case O(n)
  - check_alarms checks the earliest alarm, triggers it if time is up and then
    repeats. This does not check every element in the queue everytime, so it
    usually acts within O(1).
  - However, it will trigger every alarm it can possibly do so it can take up to
    O(n) in those cases.
  - alarms are ran instantly inside interrupt handler, which means we must
    assume that they run fast without blocking, io or any long computation
test_alarm.c
  - tests for the alarm and sleeping
    - Normally, this is impossible because user threads cannot directly register
      alarms
  - two threads set up alarms so that "HELLO" is printed once a second
    - alarms registered in arbitrary order with sleeps in between.

================================================================================
Pqueue

This is a file we added to act as a priority queue for alarms

pqueue.h
  - The interface for this is mostly the same as the interface for queue.h
    - The only difference is that we also need to provide a priority
  - We also provide a pqueue_peek function to allow viewing of the head
    of the priority queue without having to dequeue first
pqueue.c
  - This is implemented similarly to queue.c
  - enqueue iterates over the queue until it finds a location that has a higher
    priority
  - enqueue, free and delete run in O(n)
  - new, dequeue, peek, length run in O(1)
pqueue_test.c
  - unit tests for priority queue

================================================================================
Multilevel_queue

multilevel_queue.h
  - No change other than adding a length function
multilevel_queue.c
  - in new, we malloc the multiqueue, then the array of queues, then each queue
    in the array. If any of these mallocs fail, we free up all the successful
    mallocs previously and return NULL
  - enqueue and dequeue both fail if passed a nonexistant level (too high/low)
  - dequeue starts at the input level and then continues to check levels in
    increasing order. If it reaches the last level, it wraps around to 0.
mqueue_test.c
  - unit tests for multilevel_queue

================================================================================
Synch

synch.h
  - No changes made
synch.c
  - Modified semaphore P and V to be interrupt safe
    - disabled interrupts through entire body

================================================================================
Minithread

minithread.h
  - status is represented by an enum of NEW, WAITING, READY, RUNNING, or ZOMBIE
  - minithread_exit is called when a thread finally returns and marks the thread
    for garbage collection
minithread.c
  - This is where our scheduler is also located
  - thread control blocks have an id, a status, and pointers to the stack
  - We save several states globally: the system stack (explained below), the
    currently running thread, a queue of ready threads, a queue of zombie
    threads, and an incrememting counter for assigning new ids.
  - Thread ids are assigned in order, starting at 0
  - We disallow starting already started threads (status READY) and zombie
    threads.
  - When yielding with 1 thread left, no context switch is performed, only
    a garbage collection step is performed.
  - We start by forking the main process and begin scheduling

scheduler
  - basic FIFO queue
  - There are two pieces of the scheduler: minithread_next and scheduler
  - We have a main "system" thread that is only running scheduler()
    - this is not a minithread, but actually just the same thread as main()
  - scheduler() can only be run by this system thread and blocks (spins) while
    the ready queue is empty
  - Once there is something in the ready queue, it will schedule it and switch
  - minithread_next is run on individual minithreads when they need to swap to
    a new thread
  - If there is something in the ready queue, then it will swap to it, otherwise
    it will swap back to the system thread to block on the ready queue

reaper
  - Our reaper thread P's on a garbage semaphore and then cleans up that
    piece of garbage.
  - interrupts disabled when dequeueing off zombie queue

test_int.c
  - test for our scheduling
  - two threads constantly running and not yielding printing incrementing
    numbers after a delay
  - both threads should start out very interleaved (quanta level 0) and then
    slowly reach a point where one executes for a while (8 quantas, level 3)
    and then swaps
================================================================================
